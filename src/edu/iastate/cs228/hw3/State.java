package edu.iastate.cs228.hw3;

import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Scanner;

/**
 *  
 * @author	Irfan Farhan Mohamad Rafie
 *
 */


/**
 * This class represents a board configuration in the 8-puzzle.  Only the initial configuration is 
 * generated by a constructor, while intermediate configurations will be generated via calling
 * the method successorState().  State objects will form two circular doubly-linked lists OPEN and 
 * CLOSED, which will be used by the A* algorithm to search for a path from a given initial board
 * configuration to the final board configuration below: 
 * 
 *  1 2 3 
 *  8   4
 *  7 6 5
 *
 * The final configuration (i.e., the goal state) above is not explicitly represented as an object 
 * of the State class. 
 */

public class State implements Cloneable, Comparable<State>
{
	public int[][] board; 		// configuration of tiles 
    private int[][] goalState = {{1, 2, 3} , {8, 0, 4}, {7, 6, 5}};

    public State previous;    	// previous node on the OPEN/CLOSED list
	public State next; 			// next node on the OPEN/CLOSED list
	public State predecessor; 	// predecessor node on the path from the initial state 
	
	public Move move;           // the move that generated this state from its predecessor
	public int numMoves; 	    // number of moves from the initial state to this state

	public static Heuristic heu; // heuristic used. shared by all the states.

	private int numMismatchedTiles = -1;  // number of mismatched tiles between this state 
	                                      // and the goal state; negative if not computed yet.
	private int ManhattanDistance = -1;   // Manhattan distance between this state and the 
	                                      // goal state; negative if not computed yet. 

	ArrayList<Integer> dupeNumbers = new ArrayList<Integer>();
	/**
	 * Constructor (for the initial state).  
	 * 
	 * It takes a 2-dimensional array representing an initial board configuration. The empty 
	 * square is represented by the number 0.  
	 * 
	 *     a) Initialize all three links previous, next, and predecessor to null.  
	 *     b) Set move to null and numMoves to zero.
	 * 
	 * @param board
	 * @throws IllegalArgumentException		if board is not a 3X3 array or its nine entries are 
	 * 										not respectively the digits 0, 1, ..., 8. 
	 */
    public State(int[][] board) throws IllegalArgumentException 
    {
        try{
            if(board.length != 3 || board[0].length != 3){
                throw new IllegalArgumentException();
            }

            for(int x = 0; x < 3; x++){
                for(int y = 0; y < 3; y++){
                    if(!dupeNumbers.contains(board[x][y])){
                        dupeNumbers.add(board[x][y]);
                    }
                    else{
                        throw new IllegalArgumentException();
                    }
                }
            }
            previous = null;
            next = null;
            predecessor = null;
            move = null;
            numMoves = 0;
        }

        catch(IllegalArgumentException e){
            e.printStackTrace();
        }

		this.board = board;
	}
    
    
    /**
     * Constructor (for the initial state) 
     * 
     * It takes a state from an input file that has three rows, each containing three digits 
     * separated by exactly one blank.  Every row starts with a digit. The nine digits are 
     * from 0 to 8 with no duplicates.  
     * 
     * Do the same initializations as for the first constructor. 
     * 
     * @param inputFileName
     * @throws FileNotFoundException
     * @throws IllegalArgumentException  if the file content does not meet the above requirements. 
     */
    public State (String inputFileName) throws FileNotFoundException, IllegalArgumentException
    {
        try{
            int[][] tempoBoard = new int[3][3];
            String[] tempString = new String[3];
            FileReader input = new FileReader(inputFileName);
            Scanner inputScan = new Scanner(input);
            int lineCount = 0;
            while(inputScan.hasNextLine()){
                tempString[lineCount] = inputScan.nextLine();
                lineCount++;
            }

            if(lineCount != 3){
                throw new IllegalArgumentException();
            }

            if((tempString[0].length() != 5) || (tempString[1].length() != 5) || (tempString[2].length() != 5)){
                throw new IllegalArgumentException();
            }

            for(int x = 0; x < 3; x++){
                tempoBoard[x][0] = tempString[x].charAt(0) - '0';
                tempoBoard[x][1] = tempString[x].charAt(2) - '0';
                tempoBoard[x][2] = tempString[x].charAt(4) - '0';
            }

            this.board = tempoBoard;



        }
        catch (IllegalArgumentException | FileNotFoundException e){
            e.printStackTrace();
        }

	}
    
    
    /**
     * Generate the successor state resulting from a given move.  Throw an exception if the move 
     * cannot be executed.  Besides setting the array board[][] properly, you also need to do the 
     * following:
     * 
     *     a) set the predecessor of the successor state to this state;
     *     b) set the private instance variable move of the successor state to the parameter m; 
     *     c) Set the links next and previous to null;  
     *     d) Update numMoves. 
     * 
     * @param m  one of the moves LEFT, RIGHT, UP, and DOWN
     * @return
     * @throws IllegalArgumentException if RIGHT when the empty square is in the left column, or 
     *                                  if LEFT when the empty square is in the right column, or 
     *                                  if UP when the empty square is in the bottom row, or 
     *                                  if DOWN when the empty square is in the top row. 
     */                                  
    public State successorState(Move m) throws IllegalArgumentException 
    {
    	// TODO
        State predec = (State) this.clone();
        int[] coord;
        coord = findCoord(0);
        int[][] tempoBoard = this.board.clone();
        switch(m){
            case LEFT:
                if(coord[1] != 2) {
                    tempoBoard[coord[0]][coord[1]] = this.board[coord[0]][coord[1] + 1];
                    tempoBoard[coord[0]][coord[1] + 1] = 0;
                }
                else {
                    throw new IllegalArgumentException();
                }
                break;

            case RIGHT:
                if(coord[1] != 0) {
                    tempoBoard[coord[0]][coord[1]] = this.board[coord[0]][coord[1] - 1];
                    tempoBoard[coord[0]][coord[1] - 1] = 0;
                }
                else {
                    throw new IllegalArgumentException();
                }
                break;
            case DOWN:
                if (coord[0] != 0) {
                    tempoBoard[coord[0]][coord[1]] = this.board[coord[0] - 1][coord[1]];
                    tempoBoard[coord[0] - 1][coord[1]] = 0;
                }
                else {
                    throw new IllegalArgumentException();
                }
                break;
            case UP:
                if (coord[0] != 2) {
                    tempoBoard[coord[0]][coord[1]] = this.board[coord[0] + 1][coord[1]];
                    tempoBoard[coord[0] + 1][coord[1]] = 0;
                }
                else {
                    throw new IllegalArgumentException();
                }
                break;

        }
        State output = new State(tempoBoard);
        output.predecessor = predec;
        output.move = m;
        numMoves++;
        this.next = null;
        this.previous = null;
    	return output;
    }
    
        
    /**
     * Determines if the board configuration in this state can be rearranged into the goal configuration. 
     * According to the appendix in the project description, we check if this state has an odd number of 
     * inversions.
     * 
     * @return true if the puzzle starting in this state can be rearranged into the goal state.
     */
    public boolean solvable()
    {
    	return (countInversions() % 2 != 0);
    }
    
    
    /**
     * Check if this state is the goal state, namely, if the array board[][] stores the following contents: 
     * 
     * 		1 2 3 
     * 		8 0 4 
     * 		7 6 5 
     * 
     * @return  true if board is the same as goal state
     */
    public boolean isGoalState()
    {
        return (computeNumMismatchedTiles() == 0);
    }
    
    
    /**
     * Write the board configuration according to the following format:
     * 
     *     a) Output row by row in three lines with no indentations.  
     *     b) Two adjacent tiles in each row have exactly one blank in between. 
     *     c) The empty square is represented by a blank.  
     *     
     * For example, 
     * 
     * 2   3
     * 1 8 4
     * 7 6 5  
     * 
     */
    @Override 
    public String toString()
    {
        String output = "";
        for(int x = 0; x < 3; x++){
            for (int y = 0; y < 3; y++){
                String print = Integer.toString(board[x][y]);
                if(print.charAt(0) == '0'){
                    print = " ";
                }
                if(y != 2){
                    output = output + print + " ";
                }
                else {
                    output = output + print + "\n";
                }
            }
        }
    	return output;
    }
    
    
    /**
     * Create a clone of this State object by copying over the board[][]. Set the links previous,
     * next, and predecessor to null. 
     * 
     * The method is called by SuccessorState(); 
     */
    @Override
    public Object clone()
    {
        int[][] temp = new int[3][3];
        State newBoard = null;
        for(int x = 0; x < 3; x++){
            for(int y = 0; y < 3; y++){
                temp[x][y] = board[x][y];
            }
        }
            newBoard = new State(temp);
            newBoard.previous = null;
            newBoard.next = null;
            newBoard.predecessor = null;
        return newBoard;
    }
  

    /**
     * Compare this state with the argument state.  Two states are equal if their arrays board[][] 
     * have the same content.
     */
    @Override 
    public boolean equals(Object o)
    {
        if(this.getClass() != o.getClass()){
            return false;
        }

        State tempState = (State)o;
        int[][] temp = new int[3][3];
        for(int x = 0; x < 3; x++){
            for(int y = 0; y < 3; y++){
                if(this.board[x][y] != tempState.board[x][y]){
                    return false;
                }
            }
        }

    	return true;
    }
        
    
    /**
     * Evaluate the cost of this state as the sum of the number of moves from the initial state and 
     * the estimated number of moves to the goal state using the heuristic stored in the instance 
     * variable heu. 
     * 
     * If heu == TileMismatch, add up numMoves and the return values from computeNumMismatchedTiles().
     * If heu == MahattanDist, add up numMoves and the return values of computeMahattanDistance(). 
     * 
     * @param
     * @return estimated number of moves from the initial state to the goal state via this state.
     * @throws IllegalArgumentException if heuristic is neither 0 nor 1. 
     */
    public int cost() throws IllegalArgumentException
    {
        if(heu == Heuristic.TileMismatch){
            return numMoves + computeNumMismatchedTiles();
        }
        else if(heu == Heuristic.ManhattanDist){
            return numMoves + computeManhattanDistance();
        }

        if(heu != Heuristic.TileMismatch || heu != Heuristic.ManhattanDist){
            throw new IllegalArgumentException();
        }

        return 0;
    }

    
    /**
     * Compare two states by the cost. Let c1 and c2 be the costs of this state and the argument state s.
     * 
     * @return -1 if c1 < c2 
     *          0 if c1 = c2 
     *          1 if c1 > c2 
     *          
     * Call the method cost(). This comparison will be used in maintaining the OPEN list by the A* algorithm.
     */
    @Override
    public int compareTo(State s)
    {
    	if(this.cost() < s.cost()){
    	    return -1;
        }

        else if(this.cost() > s.cost()){
    	    return 1;
        }

        else{
    	    return 0;
        }
    }
    

    /**
     * Return the value of numMismatchedTiles if it is non-negative, and compute the value otherwise. 
     * 
     * @return number of mismatched tiles between this state and the goal state. 
     */
	private int computeNumMismatchedTiles()
	{
	    int misMatch = 0;

        for(int x = 0; x < 3; x++){
	        for(int y = 0; y < 3; y++){
	            if(this.board[x][y] != goalState[x][y] && (this.board[x][y] != 0)){
	                misMatch++;
                }
            }
        }
		return misMatch;
	}

	
	/**
	 * Return the value of ManhattanDistance if it is non-negative, and compute the value otherwise.
	 * @return Manhattan distance between this state and the goal state. 
	 */
	private int computeManhattanDistance()
	{
        int dist = 0;
        /*
                     Goal State
                        1 2 3
                        8 0 4
                        7 6 5
         */

        for(int x = 0; x < 3; x++){
            for(int y = 0; y < 3; y++){
                if(this.board[x][y] != goalState[x][y] && this.board[x][y] != 0){
                    dist += findDistance(board[x][y], x, y);
                }
            }
        }

        return dist;
	}

    /**
     * checks if all numbers from 0 to 8 is present and only appears once
     * @return  true if all numbers are present and no duplicates, else false
     */
	private boolean allPresentCheck(){
	    int x1 = 0;
        int x2 = 0;
        int x3 = 0;
        int x4 = 0;
        int x5 = 0;
        int x6 = 0;
        int x7 = 0;
        int x8 = 0;
        int x9 = 0;
	    for(int x = 0; x < 3; x++){
	        for(int y = 0; y < 3; y++){
	            if(board[x][y] == 0){
	                x1++;
                }
                else if(board[x][y] == 1){
	                x2++;
                }
                else if(board[x][y] == 2){
                    x3++;
                }
                else if(board[x][y] == 3){
                    x4++;
                }
                else if(board[x][y] == 4){
                    x5++;
                }
                else if(board[x][y] == 5){
                    x6++;
                }
                else if(board[x][y] == 6){
                    x7++;
                }
                else if(board[x][y] == 7){
                    x8++;
                }
                else if(board[x][y] == 8){
                    x9++;
                }
                else {
	                return false;
                }
            }
        }

	    if(x1 + x2 + x3 + x4 + x5 + x6 + x7 +x8 + x9 == 9){
	        return true;
	    }
	    else return false;
    }

    private int findDistance(int i, int xCoord, int yCoord){
	    for(int x = 0; x < 3; x++){
	        for(int y = 0; y < 3; y++){
	            if(goalState[x][y] == i){
	                return Math.abs(x - xCoord) + Math.abs(y - yCoord);
                }
            }
        }
        return 0;
    }

    private int[] findCoord(int check){
	    int[] temp = new int[2];
        for (int x = 0; x < 3; x++){
            for(int y = 0; y < 3; y++){
                if(this.board[x][y] == check){
                    temp[0] = x;
                    temp[1] = y;
                }
            }
        }
        return temp;
	}

	private int countInversions(){
	    int[] temp = new int[]{1, 2, 3, 4, 5, 6, 7, 8, 0};
        int a = 0;
	    for(int x = 0; x < 3; x++){
	        for(int y = 0; y < 3; y++){
	            temp[a] = board[x][y];
	            a++;
            }
        }
        int counter = 0;

        for(int i = 0; i < 9; i++){
            for(int o = 0+i; o < 9; o++){
                if(temp[i] > temp[o] && temp[o] != 0){
                    counter++;
                }
            }
        }
	    return counter;
    }
}
